import {
  object,
  string,
  isoTimestamp,
  optional,
  boolean,
  array,
  minLength,
  nullish,
  union,
  number,
  partial,
  integer,
  minValue,
  unknown,
  type Output
} from "valibot";
import { snowflake } from "@discordkit/core";
import { stickerSchema } from "../../sticker/types/Sticker.js";
import { applicationSchema } from "../../application/types/Application.js";
import { userSchema } from "../../user/types/User.js";
import { reactionSchema } from "./Reaction.js";
import { channelSchema } from "./Channel.js";
import { messageActivitySchema } from "./MessageActivity.js";
import { channelMentionSchema } from "./ChannelMention.js";
import { embedSchema } from "./Embed.js";
import { messageReferenceSchema } from "./MessageReference.js";
import { attachmentSchema } from "./Attachment.js";
import { messageTypeSchema } from "./MessageType.js";
import { messageInteractionSchema } from "./MessageInteraction.js";
import { messageComponentSchema } from "./MessageComponent.js";
import { roleSubscriptionDataSchema } from "./RoleSubscriptionData.js";

export const messageSchema = object({
  /** id of the message */
  id: snowflake,
  /** id of the channel the message was sent in */
  channelId: snowflake,
  /** user object	the author of this message (not guaranteed to be a valid user, see below) */
  author: userSchema,
  /** contents of the message */
  content: string(),
  /** when this message was sent */
  timestamp: string([isoTimestamp()]),
  /** when this message was edited (or null if never) */
  editedTimestamp: optional(string([isoTimestamp()])),
  /** whether this was a TTS message */
  tts: boolean(),
  /** whether this message mentions everyone */
  mentionEveryone: boolean(),
  /** users specifically mentioned in the message */
  mentions: array(userSchema),
  /** roles specifically mentioned in this message */
  mentionRoles: array(string([minLength(1)])),
  /** channels specifically mentioned in this message */
  mentionChannels: nullish(array(channelMentionSchema)),
  /** any attached files */
  attachments: array(attachmentSchema),
  /** any embedded content */
  embeds: array(embedSchema),
  /** reactions to the message */
  reactions: nullish(array(reactionSchema)),
  /** used for validating a message was sent */
  nonce: nullish(union([number(), string()])),
  /** whether this message is pinned */
  pinned: boolean(),
  /** if the message is generated by a webhook, this is the webhook's id */
  webhookId: nullish(snowflake),
  /** type of message */
  type: messageTypeSchema,
  /** sent with Rich Presence-related chat embeds */
  activity: nullish(messageActivitySchema),
  /** sent with Rich Presence-related chat embeds */
  application: nullish(partial(applicationSchema)),
  /** if the message is an Interaction or application-owned webhook, this is the id of the application */
  applicationId: nullish(snowflake),
  /** data showing the source of a crosspost, channel follow add, pin, or reply message */
  messageReference: nullish(messageReferenceSchema),
  /** message flags combined as a bitfield */
  flags: nullish(number([integer(), minValue(0)])),
  /** sent if the message is a response to an Interaction */
  interaction: nullish(messageInteractionSchema),
  /** the thread that was started from this message, includes thread member object */
  thread: nullish(channelSchema),
  /** sent if the message contains components like buttons, action rows, or other interactive components */
  components: nullish(array(messageComponentSchema)),
  /** sent if the message contains stickers */
  stickerItems: nullish(array(stickerSchema)),
  /** @deprecated the stickers sent with the message */
  stickers: nullish(array(stickerSchema)),
  /** A generally increasing integer (there may be gaps or duplicates) that represents the approximate position of the message in a thread, it can be used to estimate the relative position of the message in a thread in company with totalMessageSent on parent thread */
  position: number([integer()]),
  /** data of the role subscription purchase or renewal that prompted this `ROLE_SUBSCRIPTION_PURCHASE` message */
  roleSubscriptionData: nullish(roleSubscriptionDataSchema),
  /** data for users, members, channels, and roles in the message's auto-populated select menus */
  resolved: nullish(unknown()), // intentionally unknown because it would cause a cyclical dependency
  /** the message associated with the messageReference */
  referencedMessage: optional(unknown()) // This could have infinite recursion, so we skip parsing this value
});

export type Message = Output<typeof messageSchema>;
